#include <smp.h>
#include <cpu.h>
#include <hal.h>
#include <tss.h>
#include <kcpuid.h>
#include <kstring.h>
#include <paging.h>
#include <physical_allocator.h>
#include <acpi/acpi.h>
#include <timer.h>
#include <apic.h>
#include <logging.h>
#include <idt.h>

#include "smpdefines.inc"

extern gdt_t GDT64Pointer64;

extern void* _binary_smptrampoline_bin_start;
extern void* _binary_smptrampoline_bin_size;

volatile uint16_t* smp_magic = (uint16_t*)SMP_TRAMPOLINE_DATA_MAGIC;
volatile uint16_t* smp_id = (uint16_t*)SMP_TRAMPOLINE_CPU_ID;
gdt_t* smp_gdt = (gdt_t*)SMP_TRAMPOLINE_GDT_PTR;
volatile uint64_t* smp_cr3 = (uint64_t*)SMP_TRAMPOLINE_CR3;
volatile uint64_t* smp_stack = (uint64_t*)SMP_TRAMPOLINE_STACK;
volatile uint64_t* smp_entry2 = (uint64_t*)SMP_TRAMPOLINE_ENTRY2;

volatile bool done_init;

namespace smp {
    cpu* cpus[256];
    unsigned processor_count = 1;
    tss_t tss1 __attribute__((aligned(16)));

    [[noreturn]] static void smp_entry(uint16_t id) {
        cpu* c = cpus[id];
        set_cpu_local(c);

        c->gdt = memory::kernel_allocate_4k_pages(1);
        memory::kernel_map_virtual_memory_4k(memory::allocate_physical_block(), (uintptr_t)c->gdt, 1);
        memcpy(c->gdt, (void *)GDT64Pointer64.base, GDT64Pointer64.limit + 1);
        c->gdt_ptr = { .limit = GDT64Pointer64.limit, .base = (uint64_t)c->gdt };

        asm volatile("lgdt (%%rax)" :: "a"(&c->gdt_ptr));
        idt_flush();

        tss::initialize_tss(&c->tss, c->gdt);
        apic::local::enable();

        done_init = true;

        asm("sti");
        while(true) {
            asm("hlt");
        }
    }

    static void initialize_cpu(uint16_t id) {
        cpu* c = new cpu();
        c->id = id;
        cpus[id] = c;

        *smp_magic = 0;
        *smp_id = id;
        *smp_entry2 = (uint64_t)smp_entry;
        *smp_stack = (uint64_t)memory::kernel_allocate_4k_pages(1);
        memory::kernel_map_virtual_memory_4k(memory::allocate_physical_block(), *smp_stack, 1);
        *smp_stack += memory::PAGE_SIZE_4K;
        *smp_gdt = GDT64Pointer64;

        asm volatile("mov %%cr3, %%rax" : "=a"(*smp_cr3));

        apic::local::send_ipi(id, apic::ICR_DSH_DEST, apic::ICR_MESSAGE_TYPE_INIT, 0);
        timer::wait(20);

        // The trampoline code sets this when it starts, check it
        if((*smp_magic) != SMP_MAGIC) {
            apic::local::send_ipi(id, apic::ICR_DSH_DEST, apic::ICR_MESSAGE_TYPE_STARTUP, (SMP_TRAMPOLINE_ENTRY >> 12));
            timer::wait(80);
        }

        if((*smp_magic) != SMP_MAGIC) {
            timer::wait(100);
        }

        if((*smp_magic) != SMP_MAGIC) {
            log::error("[SMP] Failed to start CPU #%d", id);
            return;
        }

        while(!done_init);

        done_init = false;
    }

    void initialize() {
        uint64_t rax = 1, rbx, rcx, rdx;
        _cpuid(&rax, &rbx, &rcx, &rdx);
        uint8_t bspid = (rbx >> 24) & 0xFF;

        cpus[0] = new cpu();
        cpus[0]->id = bspid;
        cpus[0]->gdt = (void *)GDT64Pointer64.base;
        cpus[0]->gdt_ptr = GDT64Pointer64;
        set_cpu_local(cpus[0]);

        if(hal::smp_disabled()) {
            tss::initialize_tss(&cpus[bspid]->tss, cpus[bspid]->gdt);
            acpi::disable_smp();
            processor_count = 1;
            return;
        }

        processor_count = acpi::get_proc_count();

        // Note, this cryptic looking _binary stuff is generated by the bintoelf.sh script
        memcpy((void *)SMP_TRAMPOLINE_ENTRY, &_binary_smptrampoline_bin_start, ((uint64_t)&_binary_smptrampoline_bin_size));

        for(int i = 0; i < processor_count; i++) {
            if(acpi::get_processors()[i] != bspid) {
                initialize_cpu(acpi::get_processors()[i]);
            }
        }

        tss::initialize_tss(&cpus[bspid]->tss, cpus[bspid]->gdt);
        log::info("[SMP] %u processors initialized!", processor_count);
    }
}